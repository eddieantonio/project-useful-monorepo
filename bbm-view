#!/usr/bin/env python3

import copy
import sys
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from collections import defaultdict

MAX_ERRORS = 100

RED = "\x1b[31m"
BOLD = "\x1b[1m"
RESET = "\x1b[m"
GREY = "\x1b[38:5:243m"

filename = sys.argv[1]
version = sys.argv[2]


@dataclass
class Position:
    "A position in the source code file."
    line: int
    column: int

    @classmethod
    def from_attribute(cls, attribute):
        "Parse a position from either an start='' or end='' XML attribute."
        return cls(*(int(x) for x in attribute.split(":")))


@dataclass
class JavaCompilerError:
    filename: str
    text: str
    start: Position
    end: Position

    def print(self):
        print(f"{RED}{self.filename}:{self.start.line}: error: {self.text}{RESET}")

    @classmethod
    def from_element(cls, element, filename="<unknown>"):
        "Parse an compiler error from a <compile-error> XML element."
        return cls(
                text=element.text,
                filename=filename,
                start=Position.from_attribute(element.attrib['start']),
                end=Position.from_attribute(element.attrib['end']),
        )


def find_requested_version(root):
    versions_available = []

    for unit in root.findall('./unit'):
        unit_version = unit.attrib['version']
        if version == unit_version:
            return unit
        versions_available.append(unit_version)
    raise KeyError(f"Could not find version {version}. Versions available: {versions_available}")


def determine_first_line_number(unit):
    try:
        first_element = next(iter(unit))
    except StopIteration:
        # The file is empty. Just pretend the file starts on line 1.
        return 1

    return Position.from_attribute(first_element.attrib['start']).line


root = ET.parse(filename).getroot()
unit = find_requested_version(root)
unit_with_compiler_errors = copy.deepcopy(unit)

# Figure out what the source code filename is.
class_name_element = unit.find('./class/name')
if class_name_element is not None:
    class_name = class_name_element.text.strip()
    filename = f"{class_name}.java"
else:
    filename = "<unknown>"

# Get rid of the compiler errors from the version we want to print:
for pem in unit.findall('./compile-error'):
    unit.remove(pem)

pems_per_line = defaultdict(list)

# Group PEMs per each source line of code that they're on
pems_seen = 0
pems = unit_with_compiler_errors.findall('./compile-error')
for pem_element in pems:
    pem = JavaCompilerError.from_element(pem_element, filename)
    pems_per_line[pem.start.line].append(pem)
    pems_seen += 1
    if pems_seen >= MAX_ERRORS:
        break

# Need to add empty lines before the first actual line number in the file, or else the
# line numbering will be off.
first_line_number = determine_first_line_number(unit)
preceding_empty_lines = [''] * (first_line_number - 1)

source_code = "".join(unit.itertext())
source_lines = preceding_empty_lines + source_code.splitlines()

biggest_line_no_width = len(str(len(source_lines)))

for line_no, line in enumerate(source_lines, start=1):
    pems = pems_per_line.get(line_no)
    if pems is not None:
        pem = pems[0]
    else:
        pem = None

    if pem:
        pem.print()

    print(f"{line_no:>{biggest_line_no_width}} | {line}")

    if not pem:
        continue

    # columns are 1-indexed (annoyingly):
    padding = (pem.start.column - 1) * " "
    margin = ' ' * biggest_line_no_width

    if pem.start.line == pem.end.line:
        marker = '^' * max(1, pem.end.column - pem.start.column)
    else:
        marker = '^'
    print(f"{margin} | {padding}{marker}")
    print(f"{margin} |")
